# 객체

기본 문법에서, 자바스크립트의 객체를 다음과 같이 정의했습니다:  
* 객체  
객체란, 이름(name)과 값(value)으로 구성된 프로퍼티(property)의 정렬되지 않은 집합입니다. 일종의 해시테이블과 비슷한 구조를 띄고 있습니다. 단, 다른 언어의 해시테이블과 달리 값으로 함수가 올 수도 있습니다. 

자바스크립트에서 주로 사용하는 객체는 다음과 같습니다.  
1. 문서 객체(document): HTML 문서와 하위의 태그, 이미지등의 요소들을 객체화 한 모델입니다.  

2. 브라우저 관련 객체: 웹 브라우저에서 사용하는 정보를 객체화한 물건입니다. 전반적인 정보가 담긴 navigator를 비롯해 history, location, screen 등의 객체가 존재합니다.  

3. 내장 객체: 웹 브라우징을 할 때 자주 사용하는 요소를 자바 스크립트 내부에서 미리 정의해 놓은 객체입니다. Date 등이 있습니다.  
  


## 객체 만들기
객체를 만드는 방법에는 2가지가 있습니다.  
1. 객체 리터럴  
```
obj = {1: "one", 2: "two"};
```  
이름과 값을 직접 지정해줍니다. :로 구분하며, 값은 ""로 묶어줍니다.  

2. new

생성자 함수를 호출합니다. 마치 템플릿 처럼, 인자를 넣어서 서로 다른 객체 인스턴스를 호출할 수 있습니다. 
```
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function() {
    alert(this.name + ' said "hello"');
  }
}
```
일반적인 함수와 달리, 함수 이름을 대문자로 선언합니다. JS에서 대문자 함수는 관례적으로 생성자 함수를 의미합니다. 이를 통해 서로 다른 값들을 가지는 여러개의 Person 인스턴스를 만들 수 있습니다.  

* 어떤 함수이건 생성자 함수로 사용할 수 있지만, 위와 같이 this에 값을 대입하는 부분이 없다면 그냥 빈 객체를 리턴할 뿐입니다.  


* new 없이 호출하면??  
```
function Person(name, gender) {
	this.name = name;
	this.gender = gender;
}

const v = Person("hi", "hi");
```
위와 같은 코드에서, new 없이 생성자 함수를 호출했습니다. console.log로 v를 찍어보면 undefined가 찍힙니다. 어찌된 일일까요?? 리턴값이 없으니 당연한 일입니다. 저 코드는, 객체를 생성했다기 보다 그냥 함수를 호출하고 그 값을 담은 것입니다. 또 한, 저 함수에서 this는 전역객체인 window를 의미하며(기본적으로 일반 함수의 this는  전역 객체 window를 의미합니다), name과 gender라는 변수는 전역변수로 새로이 선언이 되어 프로그램이 종료될 때 까지 메모리에 남아있게 됩니다. 저 v가 지역 스코프에 선언이 되어도, 변수는 전역 영역에 계속 남아있다는 의미입니다. 
  
  
* 자바스크립트의 this  
전역 공간의 this : 전역 객체
메소드 호출 시 메소드 내부의 this : 해당 메소드를 호출한 객체
함수 호출 시 함수 내부의 this : 지정되지 않음
this가 지정되지 않은 경우 자동으로 window로 바인딩됨  
(추후 다른 페이지로 분리 요망)  


* new를 호출하면 일어나는 일  
new를 쓰면 뭔가 다를까요?  
```
function Person(name, gender) {
	this.name = name;
	this.gender = gender;
}

const v = new Person("hi", "hi");
```
다음 코드에서 무슨 일이 일어나는지를 정리해 봅시다.  
1. 함수가 실행되기 전, 빈 객체 {} 가 생성됩니다.  
2. 생성된 빈 객체가, 생성자 함수의 this로 바인딩됩니다.  
3. this, 빈 객체의 프로퍼티가 name, gender로 설정됩니다.  
4. 새로 생성된 빈 객체의 프로토타입(Object)가 생성자 함수의 프로토타입으로 설정됩니다.  
5. return 문이 따로 없다면, 자동으로 this를 리턴합니다.  

new 연산자를 이용하면, 위와 같은 과정이 자동으로 일어납니다. 따라서, return문이 없어도 알아서 새로운 객체가 반환되는 것입니다.  

* Object가 뭐죠?  
자바스크립트는, 모든 객체가 프로토타입의 복제본입니다. 그렇다면 모든 객체의 원형 역시 존재하는데, 이를 Object 객체라고 합니다.  

<!-- * 생성자 함수를 호출하면 무슨 일이 일어나나?
자바스크립트는, 모든 객체가 프로토타입의 복제본입니다. 그렇다면 모든 객체의 원형 역시 존재하는데, 이를 Object 객체라고 합니다.  

위에서 생성자 함수를 호출한다는 것도, C++이나 자바에서 클래스를 이용해 객체를 생성하는 것과는 느낌이 다릅니다. 그 과정을 대략적으로 그리면 (완전히 정확한 것은 아닙니다)

1. Object 객체로 부터 빈 객체 생성  
2. 빈 객체에 인자로 넘겨받은 프로퍼티들을 세팅  
3. 해당 객체를 리턴 -->




<!-- * 클래스는 없나요?
자바스크립트는 일반적으로 생각하는 객체 지향 언어와 달리, 클래스라는 틀에서 객체를 찍어내는 느낌은 아닙니다. 하나의 객체를 만들고, 그것을 프로토타입으로 하여 객체를 복사하거나, 요소를 추가하여 복사하는 등(상속)의 동작을 할 수 있습니다. 하지만 객체지향의 클래스 인스턴스화와, 상속과 1대1로 대응된다고 보기는 어렵습니다.
예를 들어 마치 클래스같아 보이는 생성자 함수를 통한 객체 인스턴스화를 봅시다. 생성자 함수를 호출할 때는, 다음 과정을 거칩니다.
빈 객체 생성 -> 
위에서 소개한 객체들의 경우 생성자 함수들이 미리 정의되어 있으며, 코드 내에서 사용할 때는 해당 생성자 함수들을 객체로 인스턴스화 하여 사용합니다. 

* 복사된 객체 A를 또 다시 복사하여 B를 만드는 경우, B의 프로토타입은 A가 됩니다. 프로토타입의 원형은,  
```
B.__proto__
```
와 같은 식으로 불러와서 확인할 수 있습니다. -->

자바스크립트의 프로토타입 이해하기: 
https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67  
https://developer-talk.tistory.com/538

