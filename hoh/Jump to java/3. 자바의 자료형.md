자바의 자료형은, 크게 원시타입과 참조타입으로 나뉜다. 

1. 원시타입의 경우, 스택 영역에 타입의 값 자체를 저장한다. 다른 원시 타입에 대입하는 경우 값이 복사되기 때문에, 원본 값을 변경해도 대입된 복사본에 영향을 미치지 못한다.
    
    boolean, char, byte, short int, long, float, double 등이 이에 속한다.
    
2. 참조타입의 경우, 실제 데이터는 힙 영역에 생성되며 타입 자체는 힙 영역에 있는 실제 데이터를 가리키는 주소를 스택 영역에 저장한다. 따라서 참조타입끼리 단순 대입을 할 경우 주소를 복사하기 때문에, 원본 값이 변경되면 복사본도 바뀐다(얕은 복사).
    
    문자열, 배열, 열거형, 클래스, 각종 인터페이스 등이 이에 속한다.
    
3. 특별한 케이스로 Wrapper 클래스가 있는데, 위의 원시타입들을 다시 클래스에 넣어 참조타입 처럼 만든 것이다. 위의 원시타입의 첫 글자만 대문자로 바뀐 형태를 하고 있다. 나중에 다룰 것이다.

또한 mutable, immutable로도 구분할 수 있다. mutable은 값의 변경이 가능하며, immutable은 값을 변경할 수 없는 자료형을 의미한다. 

1. mutable은 값의 변경이 가능하다. final이 붙지 않은 모든 원시타입은 mutable하다. 
    
    Q. Array는 mutable한가?
    
    Q. final은 immutable한가?
    
    → immutable 객체는, 단지 해당 객체의 값의 변경이 안될 뿐 어떤 객체를 참조할 지는 바꿀 수 있다(주소를 변경할 수 있다). 값이 바뀐 것 같이 보이는 것도 새로운 객체를 할당하고 여길 참조하도록 주소를 변경했기 때문이다. final의 경우는 주소조차 바꿀 수 없다. 이런 의미에서 final = immutable하다고 하지는 않는다.
    
2. immutable은 값의 변경이 불가능하다. String과 모든 Wrapper 클래스가 여기 속한다. 값을 변경하는 것 처럼 보이는 경우도, 새로운 객체를 재 할당 받는 것이지 기존 객체의 값을 변경하는 것은 아니다.
- Wrapper 클래스가 존재하는 이유 중 하나인데, immutable 객체의 경우 값이 바뀌지 않기 때문에 데이터 레이싱 문제에서 안전하며, 따라서 thread-safe 하다고 표현한다. 멀티 스레드 프로그래밍에서는 모든 원시타입을 Wrapper 클래스로 치환해서 사용한다.